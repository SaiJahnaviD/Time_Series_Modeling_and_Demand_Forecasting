# -*- coding: utf-8 -*-
"""Time_Series_Modeling_and_Demand_Forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MtnUiD5EGRr5HZWLM4hiUR6JKoeiZZDN

Dataset Selection
"""

!pip install --upgrade yfinance

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np
from statsmodels.tsa.statespace.sarimax import SARIMAX

"""# Analysis of NVIDIA"""

ticker = "NVDA"
df = yf.download(ticker, start="2024-01-01", end="2025-01-01")

# Reset index to make 'Date' a column
df.reset_index(inplace=True)

# Drop the 'ticker' level from multi-index columns if it exists
if isinstance(df.columns, pd.MultiIndex):
    df.columns = df.columns.get_level_values(0)

# Rename columns to match the convention (Open_NVDA, Close_NVDA, etc.)
df.rename(columns={
    'Open': 'Open_NVDA',
    'High': 'High_NVDA',
    'Low': 'Low_NVDA',
    'Close': 'Close_NVDA',
    'Adj Close': 'AdjClose_NVDA',
    'Volume': 'Volume_NVDA',
    'Date': 'Date_'
}, inplace=True)
print(df.head())

df

"""## Data Preprocessing (NVDA)

### Univariate Analysis
"""

# Plotting
features_nvda = ['Open_NVDA', 'High_NVDA', 'Low_NVDA', 'Close_NVDA', 'Volume_NVDA']

plt.figure(figsize=(12, 16))
for i, feature in enumerate(features_nvda):
    plt.subplot(len(features_nvda), 2, 2 * i + 1)
    sns.histplot(df[feature], kde=True, color='skyblue')
    plt.title(f"{feature} - Histogram")

    plt.subplot(len(features_nvda), 2, 2 * i + 2)
    sns.boxplot(y=df[feature], color='lightcoral')  # Changed x= to y=
    plt.title(f"{feature} - Boxplot")

plt.tight_layout()
plt.show()

"""Interpretation of each column’s distribution and key observations:

1. Open_NVDA (Opening Price)
Histogram: The opening prices appear to be bimodal, with two peaks around 95-105 and 120-135, indicating that the price had two distinct levels throughout the year.
Boxplot: The distribution is fairly symmetric, with no significant outliers. Prices ranged approximately from 50 to 150 during the period.
Key Insight: NVIDIA’s stock had two distinct price zones, likely indicating periods of growth or consolidation.

2. High_NVDA (Highest Price of the Day)
Histogram: Similar to Open, the high prices exhibit a bimodal distribution, reflecting the same pattern of two main price zones during the year.
Boxplot: No extreme outliers. The spread is comparable to the Open prices, showing a gradual increase in price levels.
Key Insight: The daily highs closely followed the opening price patterns, suggesting consistent upward momentum on days with high trading.

3. Low_NVDA (Lowest Price of the Day)
Histogram: Also bimodal, reflecting the same two price ranges.
Boxplot: No significant outliers. The low price range is consistent with the open and high prices, which is expected.
Key Insight: The low prices followed the overall price movements, showing stability with minimal drastic daily drops.

4. Close_NVDA (Closing Price)
Histogram: Bimodal distribution, mirroring the patterns seen in the Open, High, and Low prices.
Boxplot: No significant outliers, and the spread is consistent with other price variables.
Key Insight: The closing prices reflect the overall growth and transition between price levels, further confirming that NVIDIA’s stock experienced upward movement in stages during the year.

5. Volume_NVDA (Number of Shares Traded)
Histogram: Right-skewed distribution, meaning most days had lower trading volume, but there were a few days with exceptionally high trading activity.
Boxplot: Several outliers on the higher end, indicating spikes in trading volume on specific days.
Key Insight: There were periods of intense market activity, likely driven by major announcements, earnings releases, or market news. Volume spikes often coincide with price movements, making volume an important indicator for identifying significant events.
"""



"""### Bi-variate Analysis"""

# Select only numeric columns (Open, High, Low, Close, Volume)
numeric_columns = ['Open_NVDA', 'High_NVDA', 'Low_NVDA', 'Close_NVDA', 'Volume_NVDA']
df_numeric = df[numeric_columns]

# Correlation Matrix
correlation_matrix = df_numeric.corr()

# Plotting the Correlation Heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap="coolwarm", linewidths=0.5)
plt.title('Correlation Matrix - NVIDIA Stock Data')
plt.show()

"""### Correlation Matrix
As part of the bivariate analysis, I generated a correlation matrix to examine the relationships between the numerical variables in the NVIDIA (NVDA) stock price dataset. The correlation matrix provides Pearson’s correlation coefficients, which measure the strength and direction of linear relationships between pairs of variables.

The values range from:

- +1 → Perfect positive correlation (as one variable increases, the other increases).
- -1 → Perfect negative correlation (as one variable increases, the other decreases).
- 0 → No linear relationship.

#### Key Observations from the Correlation Matrix:

#### Open, High, Low, and Close Prices:

These variables are very strongly positively correlated (close to 1.00), indicating that NVIDIA’s stock price movements are closely tied throughout the day.

This is expected because the stock’s price typically fluctuates within a certain range during a trading session, and these values tend to move in the same direction.


#### Volume and Price Variables (Open, High, Low, Close):

There is a moderate negative correlation (approximately -0.62 to -0.66) between Volume and the stock price variables.
This negative relationship suggests that higher trading volumes are often associated with lower stock prices during the analyzed period. This could indicate selling pressure during high-volume trading days, which is common in volatile or corrective phases.
"""



"""## Multi-variate Analysis

Hypothesis:

"Higher trading volume is associated with lower opening stock prices, and this relationship varies depending on the closing price."


- Volume_NVDA (Trading Volume) → Independent Variable
- Open_NVDA (Opening Price) → Dependent Variable
- Close_NVDA (Closing Price) → Used as a third variable to differentiate data points using color.


This hypothesis suggests that days with high trading volume may correspond to lower opening prices, and the closing price may influence the relationship between volume and opening price.
"""

plt.figure(figsize=(10, 6))
scatter = plt.scatter(
    df['Volume_NVDA'],
    df['Open_NVDA'],
    c=df['Close_NVDA'],
    cmap='coolwarm',  # Color gradient based on closing price
    alpha=0.7,
    edgecolors='black'
)

plt.title('Multivariate Analysis: Volume vs. Open Price (Colored by Close Price)')
plt.xlabel('Volume_NVDA')
plt.ylabel('Open_NVDA')

# Add color bar to represent Close_NVDA values
cbar = plt.colorbar(scatter)
cbar.set_label('Close_NVDA')

plt.show()

"""###vAnalysis of the Scatter Plot – Multivariate Analysis (Volume, Open, Close Prices)

Restating the Hypothesis:
"Higher trading volume is associated with lower opening stock prices, and this relationship varies depending on the closing price."

Visual Analysis from the Scatter Plot:
Volume vs. Open Price Relationship:

- Negative relationship: There is a visible downward trend in the scatter plot; as Volume_NVDA increases, Open_NVDA tends to be lower.
- High Volume (0.5B to 1.0B) is associated with lower opening prices (~50 to 90).
- Low Volume (0.1B to 0.3B) is associated with higher opening prices (~120 to 150).

Role of Close_NVDA (Color Gradient):

- Color gradient (blue to red) aligns with the Open prices:
- Lower opening prices (60 and below) tend to be blue → Lower Close prices.
- Higher opening prices (~120-150) are red → Higher Close prices.
- This suggests that Open and Close prices are strongly related (which is expected from your correlation matrix), and Volume seems to inversely relate to both.

### Conclusion:
The hypothesis is supported by the scatter plot:

- Higher trading volume tends to be associated with lower opening prices.
- The relationship is influenced by closing prices, as seen from the color gradient, with lower closing prices generally aligning with lower opening prices and higher volume.
"""



"""## Model Building (NVDA)

### Time Series EDA

To better understand the structure and behavior of **NVIDIA’s stock price data over time,** I am conducting **Exploratory Data Analysis** (EDA) for time series.

Unlike standard EDA, time series analysis focuses on identifying patterns and components that evolve over time. This allows us to uncover the underlying structure of the data before building forecasting models.

In time series data, we typically examine four key components:

- **Trend:** The long-term direction in which the stock price is moving.
- **Seasonality:** Repeating patterns over a fixed period, such as weekly, monthly, or quarterly effects.
- **Cyclical Variation:** Fluctuations around the trend that occur over longer periods, often influenced by broader economic or market cycles.
- **Irregular Events:** Unexpected and random movements caused by external factors, such as company news, global events, or market shocks.

By analyzing these components, we can gain valuable insights into NVIDIA’s stock price behavior, detect patterns, and identify factors driving price changes, which will ultimately support the development of an accurate time series forecasting model.
"""

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.plot(df['Date_'], df['Close_NVDA'], color='blue', label='Close Price')
plt.title('NVIDIA (NVDA) Stock Price Time Series (2024)')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.grid(True)
plt.show()

"""- The raw time series plot displays a strong upward trend in NVIDIA’s stock price throughout 2024, reflecting the company’s growth, particularly driven by its dominance in AI chips and increasing investor interest. with some short-term fluctuations and corrections along the way.

- Sharp increases and occasional dips suggest irregular events like earnings reports or market reactions, while no clear seasonality pattern is visible.

- The stock price starts low (around 50) in January and rises above 140 by the end of the year, but with visible fluctuations and corrections along the way.
"""

decomposition = seasonal_decompose(df['Close_NVDA'], model='additive', period=30)  # Assuming ~30-day monthly seasonality

plt.figure(figsize=(10, 8))
plt.subplot(4, 1, 1)
plt.plot(df['Date_'], df['Close_NVDA'], label='Original')
plt.legend()

plt.subplot(4, 1, 2)
plt.plot(df['Date_'], decomposition.trend, label='Trend')
plt.legend()

plt.subplot(4, 1, 3)
plt.plot(df['Date_'], decomposition.seasonal, label='Seasonality')
plt.legend()

plt.subplot(4, 1, 4)
plt.plot(df['Date_'], decomposition.resid, label='Residual (Irregular)')
plt.legend()

plt.tight_layout()
plt.show()

"""### 2. Trend Component
- A smooth upward trajectory is observed, confirming a positive long-term trend throughout the year.

- Slight flattening is noticeable from July to September, indicating a period of consolidation or slower growth, which aligns with the volatility seen in the original plot during this period.

- Growth resumes strongly from September to November, likely driven by earnings results, product launches, or broader market sentiment favoring AI and tech stocks.

#### Key Insight:
The long-term growth trend suggests NVIDIA’s positive performance in 2024, despite temporary corrections and consolidations.

### 3. Seasonality Component
- Cyclic upward and downward patterns are visible, suggesting short-term periodic price movements.

- These oscillations seem to repeat roughly on a monthly basis, indicating possible investor behavior patterns such as anticipation around earnings reports, monthly portfolio rebalancing, or other cyclical trading behaviors.

- However, the magnitude of the seasonality is relatively small compared to the trend, indicating that while present, seasonal effects are not the dominant factor.

#### Key Insight:
There is a minor seasonality effect, potentially monthly, but it is subtle compared to the dominant upward trend.

### 4. Residual (Irregular Component)
- The residual plot captures random fluctuations and volatility that cannot be explained by the trend or seasonality.

- Periods of high irregularity are visible in June, July, and September, aligning with the downward movements and price volatility seen in the original series.

These residual spikes likely reflect irregular market events, such as:
- Earnings reports.
- AI industry news     
- Macroeconomic announcements or market corrections.

#### Key Insight:
Irregular movements indicate volatility caused by external factors, which is common in high-growth tech stocks like NVIDIA.

### Final Summary for the Report:
The decomposition analysis reveals that NVIDIA’s stock price in 2024 is primarily driven by a strong upward trend, reflecting the company’s growth and investor confidence in AI technologies.

- Minor seasonality patterns suggest possible monthly trading cycles, though less impactful than the trend.

- Irregular price fluctuations indicate market volatility due to company news and external events, especially during mid-year (June to September).


This breakdown provides valuable insights into the underlying structure of the stock price data, which will aid in selecting an appropriate forecasting model.

## Modeling - ARIMA, PACF, ACF, ADF, Seasonality

### ACF, PACF - plots identify AR and MA terms for ARIMA models

### ACF (Autocorrelation Function) → Identifies MA (q) terms.
### PACF (Partial Autocorrelation Function) → Identifies AR (p) terms
"""

df['Close_NVDA_diff'] = df['Close_NVDA'].diff()

# Drop the first row since it becomes NaN after differencing
df_diff = df['Close_NVDA_diff'].dropna()

fig, ax = plt.subplots(1, 2, figsize=(12, 5))

# ACF plot to determine q (MA order)
plot_acf(df_diff, ax=ax[0], lags=30)
ax[0].set_title("Autocorrelation Function (ACF)")

# PACF plot to determine p (AR order)
plot_pacf(df_diff, ax=ax[1], lags=30)
ax[1].set_title("Partial Autocorrelation Function (PACF)")

plt.tight_layout()
plt.show()



"""### Explanation of the ACF and PACF Plots (After Differencing) – NVIDIA Close Price

These plots displays the ACF (Autocorrelation Function) and PACF (Partial Autocorrelation Function) for the first-order differenced NVIDIA stock price data.

These plots are crucial for identifying the appropriate ARIMA(p, d, q) model parameters:

What These Plots Represent:

### 1. ACF Plot (Autocorrelation Function)
- **Purpose:** Helps determine the MA (Moving Average) component q in the ARIMA model.
- **Observation:**
    - All lags fall within the confidence interval (blue area), except for lag 0.
    - No significant spikes → Suggests q = 0.


### 2. PACF Plot (Partial Autocorrelation Function)
- **Purpose:** Helps determine the AR (Autoregressive) component p in the ARIMA model.
- **Observation:** Sharp cutoff at lag 1 (significant spike at lag 1), followed by insignificant lags within the confidence interval.
- This suggests p = 1 as a reasonable starting value.


### What Does This Mean for Model Selection?

- d = 1 → First-order differencing was applied to make the data stationary (based on ADF test result).
- p = 1 → Because the PACF plot shows a sharp spike at lag 1.
- q = 0 → Because the ACF plot shows no significant spikes.

### First Appropriate Model Suggestion for Report:

#### ARIMA(1, 1, 0)

This model reflects:

- 1 lag in the autoregressive term (p=1).
- 1 differencing step to achieve stationarity (d=1).
- 0 lags in the moving average term (q=0).

This is the most appropriate initial model based on the ACF and PACF analysis.


The ACF and PACF plots were analyzed after applying first-order differencing to achieve stationarity (d=1).

The ACF plot showed no significant spikes, suggesting q=0, while the PACF plot showed a sharp cutoff at lag 1, indicating p=1.

Based on this analysis, ARIMA(1, 1, 0) was selected as the initial model for time series forecasting.

### ADF Test
"""

train_size = int(len(df) * 0.7)

train = df['Close_NVDA'][:train_size]
test = df['Close_NVDA'][train_size:]

# Perform ADF Test on training data
adf_result = adfuller(train)

# Print Results
print(f"ADF Statistic: {adf_result[0]}")
print(f"p-value: {adf_result[1]}")
print("Critical Values:")
for key, value in adf_result[4].items():
    print(f"   {key}: {value}")

# Decision
if adf_result[1] < 0.05:
    print("The time series is stationary (p < 0.05).")
else:
    print("The time series is non-stationary (p >= 0.05). Differencing may be needed.")

"""The ADF test on the original NVIDIA stock price series indicated non-stationarity (p = 0.3447). First-order differencing was applied (d=1), and the ADF test was conducted again on the differenced series to confirm stationarity."""

train_diff = train.diff().dropna()

adf_result_diff = adfuller(train_diff)

print(f"ADF Statistic (Differenced): {adf_result_diff[0]}")
print(f"p-value (Differenced): {adf_result_diff[1]}")
print("Critical Values:")
for key, value in adf_result_diff[4].items():
    print(f"   {key}: {value}")

if adf_result_diff[1] < 0.05:
    print("The differenced series is stationary (p < 0.05).")
else:
    print("The differenced series is still non-stationary. Consider second-order differencing (d=2).")

"""The Augmented Dickey-Fuller (ADF) test was applied to the NVIDIA stock price data. The initial test on the original series indicated non-stationarity (p = 0.3447). First-order differencing was performed (d=1), and the ADF test was conducted again. The differenced series showed stationarity (p = 1.15e-27), confirming that d=1 is appropriate for ARIMA modeling.

### Summary of ADF Test and Differencing Process

To assess the stationarity of the NVIDIA stock price time series data, we first conducted the Augmented Dickey-Fuller (ADF) test on the training set, which consisted of 70% of the dataset.

The test yielded a p-value of 0.3447, indicating that the series was non-stationary. This result is expected for stock price data, as it typically exhibits a trend over time.

To address non-stationarity, first-order differencing (d=1) was applied. This transformation involves subtracting each day’s stock price from the previous day’s price, converting the series into daily price changes.

After differencing, the ADF test was performed again on the transformed data, yielding a p-value of 1.15e-27, which is far below the 0.05 significance level. This confirmed that the differenced series was stationary, making it suitable for ARIMA modeling with d=1.

With stationarity achieved, we proceeded to select the AR (p) and MA (q) parameters using ACF and PACF plots. The PACF plot showed a sharp cutoff at lag 1, suggesting p=1, while the ACF plot displayed no significant spikes, indicating q=0.


### Resulting ARIMA Model Suggestion:
Based on these findings, the initial ARIMA model was specified as ARIMA(1, 1, 0), with:

- p = 1 (AR term)
- d = 1 (Differencing)
- q = 0 (MA term)

## Models: ARIMA, SARIMA
### ARIMA Models (Non-Seasonal)

### Overview

The ARIMA (AutoRegressive Integrated Moving Average) model is a fundamental approach to time series forecasting, designed to capture non-seasonal dependencies in data.

The model is defined by three parameters (p, d, q):

- p: The number of lag observations in the autoregressive (AR) model.
- d: The number of times the data needs to be differenced to achieve stationarity.
- q: The size of the moving average (MA) window for past errors.

In this analysis, two ARIMA models were implemented to forecast NVIDIA's stock closing price using data from 2023 to 2024.
"""

train_size = int(len(df) * 0.7)
train = df['Close_NVDA'][:train_size]
test = df['Close_NVDA'][train_size:]

"""### Data Splitting

Before fitting the models, the dataset was split into training and testing sets:

- 70% for training (first 176 observations).
- 30% for testing (remaining 76 observations).
"""

# Model 1 - ARIMA(1, 1, 0)
arima_1 = ARIMA(train, order=(1, 1, 0))
arima_1_fit = arima_1.fit()
forecast_1 = arima_1_fit.forecast(steps=len(test))

rmse_1 = np.sqrt(mean_squared_error(test, forecast_1))
r2_1 = r2_score(test, forecast_1)

print(f"ARIMA(1, 1, 0) - RMSE: {rmse_1}, R²: {r2_1}")
print(arima_1_fit.summary())

# Model 2 - ARIMA(2, 1, 0)
arima_2 = ARIMA(train, order=(2, 1, 0))
arima_2_fit = arima_2.fit()
forecast_2 = arima_2_fit.forecast(steps=len(test))

rmse_2 = np.sqrt(mean_squared_error(test, forecast_2))
r2_2 = r2_score(test, forecast_2)

print(f"ARIMA(2, 1, 0) - RMSE: {rmse_2}, R²: {r2_2}")
print(arima_2_fit.summary())



"""### Model 1 – ARIMA(1, 1, 0)

#### Explanation:
- p=1 → The model considers the previous day’s closing price as a predictor.
- d=1 → First-order differencing was applied to the data to remove non-stationarity.
- q=0 → No moving average component is included.

This model is a basic autoregressive model with differencing, commonly used as a starting point in ARIMA modeling.

### Performance Metrics:
 - RMSE: 18.46 → The average prediction error is $18.46.
 - R²: -2.92 → Negative R² indicates very poor performance; the model performs worse than predicting the mean.


### Model 2 – ARIMA(2, 1, 0)
#### Explanation:
- p=2 → This model considers the previous two days' stock prices as predictors.
- d=1 → First-order differencing was applied to achieve stationarity.
- q=0 → No moving average component.

This model extends Model 1 by adding another autoregressive term, which could potentially capture more patterns.

### Performance Metrics:
- RMSE: 17.45 → Slightly better than Model 1, with lower prediction error.
- R²: -2.50 → Still negative, indicating poor performance (but slightly better than Model 1).

### Final Observation

- Both ARIMA models failed to capture the patterns in NVIDIA's stock prices, as indicated by negative R² values and high RMSE.

- Stock price data is notoriously volatile and difficult to predict, which is a known limitation of ARIMA models for financial data.

- Seasonality was not considered in these models, which could explain the poor performance, as stock prices often exhibit weekly and monthly patterns.

- The better performance of ARIMA(2, 1, 0) suggests slightly more lag terms might be useful, but further improvements likely require incorporating seasonality (SARIMA models).
"""



"""## SARIMA Models (Seasonal ARIMA)

### Overview

SARIMA (Seasonal AutoRegressive Integrated Moving Average) models extend ARIMA models by incorporating seasonality into the forecasting process.

This is particularly useful when working with stock prices, which can exhibit cyclical patterns over weekly or monthly intervals.

SARIMA models have additional seasonal components (P, D, Q, s) compared to ARIMA:

- P: Seasonal autoregressive (AR) terms.
- D: Seasonal differencing order.
- Q: Seasonal moving average (MA) terms.
- s: Seasonal period (e.g., 5 for weekly trading days in the stock market).
"""

# Model 3 - SARIMA(0, 2, 1)(1, 0, 1, 5)
sarima_1 = SARIMAX(train, order=(0, 2, 1), seasonal_order=(1, 0, 1, 5))
sarima_1_fit = sarima_1.fit()
forecast_3 = sarima_1_fit.forecast(steps=len(test))

rmse_3 = np.sqrt(mean_squared_error(test, forecast_3))
r2_3 = r2_score(test, forecast_3)

print(f"SARIMA(0, 2, 1)(1, 0, 1, 5) - RMSE: {rmse_3}, R²: {r2_3}")
print(sarima_1_fit.summary())

"""### Model 3 – SARIMA(0, 2, 1)(1, 0, 1, 5)
#### Explanation:
 - p=0, d=2, q=1 → Non-seasonal part.
    - d=2 → Second-order differencing was applied due to the non-stationary nature of stock prices.
    - q=1 → Includes one lagged error term in the moving average part.

 - P=1, D=0, Q=1, s=5 → Seasonal part.
    - s=5 → Reflects a weekly trading cycle (5 trading days).
    - P=1 → One seasonal autoregressive term.
    - Q=1 → One seasonal moving average term.

#### Performance Metrics:
 - RMSE: 7.58 → Significantly lower than the ARIMA models, indicating better predictive performance.
- R²: 0.34 → Positive R², meaning the model explains 34% of the variance in NVIDIA’s stock prices.

This represents a substantial improvement over the non-seasonal ARIMA models, which had negative R² values.
"""

# Model 4 - SARIMA(2, 1, 0)(1, 1, 0, 5)
sarima_2 = SARIMAX(train, order=(2, 1, 0), seasonal_order=(1, 1, 0, 5))
sarima_2_fit = sarima_2.fit()
forecast_4 = sarima_2_fit.forecast(steps=len(test))

rmse_4 = np.sqrt(mean_squared_error(test, forecast_4))
r2_4 = r2_score(test, forecast_4)

print(f"SARIMA(2, 1, 0)(1, 1, 0, 5) - RMSE: {rmse_4}, R²: {r2_4}")
print(sarima_2_fit.summary())

"""### Model 4 – SARIMA(2, 1, 0)(1, 1, 0, 5)

#### Explanation:

 - p=2, d=1, q=0 → Non-seasonal part.
    - p=2 → Considers two lagged stock price values.
    - d=1 → First-order differencing to achieve stationarity.
- P=1, D=1, Q=0, s=5 → Seasonal part.
    - s=5 → Weekly pattern (5 trading days).
    - D=1 → Seasonal differencing to remove seasonal trends.
    - P=1 → One seasonal autoregressive term.

#### Performance Metrics:
- RMSE: 10.15 → Higher than Model 3, indicating worse performance.
- R²: -0.18 → Negative R², indicating the model fits poorly and performs worse than predicting the mean.

### Final Observations:

Model 3 (SARIMA(0, 2, 1)(1, 0, 1, 5)) is the best model overall, with:
- Lowest RMSE (7.58).
- Positive R² (0.34) → Explains 34% of the variation in stock prices.




Model 4’s poor performance highlights the importance of second-order differencing (d=2) in this dataset, as first-order differencing (d=1) was insufficient to achieve stationarity.




Seasonality matters: The weekly seasonality (5 trading days) and seasonal components (P=1, Q=1) in Model 3 improved performance compared to ARIMA models without seasonality.

# Visualizing best model : Model-3
"""

# Fit the best SARIMA model (0, 2, 1)(1, 0, 1, 5)
best_sarima_model = SARIMAX(
    train,
    order=(0, 2, 1),
    seasonal_order=(1, 0, 1, 5)
)
best_sarima_fit = best_sarima_model.fit()

# Make predictions
sarima_predictions = best_sarima_fit.forecast(steps=len(test))

# Calculate residuals
sarima_residuals = test - sarima_predictions

# Compute metrics
sarima_rmse = np.sqrt(mean_squared_error(test, sarima_predictions))
sarima_r2 = r2_score(test, sarima_predictions)
sarima_mean_residuals = sarima_residuals.mean()

print(f"RMSE: {sarima_rmse}")
print(f"R²: {sarima_r2}")
print(f"Mean of Residuals: {sarima_mean_residuals}")

# Visualize predictions
plt.figure(figsize=(12, 6))
plt.plot(train.index, train, label="Train Data")
plt.plot(test.index, test, label="Test Data", color='orange')
plt.plot(test.index, sarima_predictions, label="SARIMA(0, 2, 1)(1, 0, 1, 5) Predictions", linestyle="dashed", color='red')
plt.title('Best SARIMA Model Predictions for NVIDIA Stock Price')
plt.xlabel("Time")
plt.ylabel("Close Price")
plt.legend()
plt.show()



"""## Forecast Visualization Analysis: SARIMA(0, 2, 1)(1, 0, 1, 5)

The graph above represents the performance of the SARIMA(0, 2, 1)(1, 0, 1, 5) model in forecasting NVIDIA’s stock price.

- **Training Period (Blue Line):**
The model was trained using approximately 70% of the data, representing NVIDIA’s stock price trends from early 2023 to the latter part of the year. The stock shows an overall upward trend with periods of volatility, which is characteristic of stock market behavior.

- **Testing Period (Orange Line):**
The remaining 30% of the data was used for testing the model’s forecasting ability. This segment captures the most recent stock price movements, including sharp price increases and fluctuations.

- **Model Forecast (Red Dashed Line):**
The SARIMA model’s prediction appears as a smooth upward-sloping dashed red line during the testing period.

- This linear pattern is a common characteristic of SARIMA models with second-order differencing (d=2).

- It suggests that the model is projecting a continued increase based on the prior upward trend.

- The forecast does not capture the short-term fluctuations observed in the actual test data.
- This highlights a limitation of the SARIMA model when applied to volatile stock price data, as it struggles to adapt to rapid price swings.


### Model Performance Evaluation:
Despite the linear prediction pattern, this SARIMA model achieved the best performance among the models tested, with:

- RMSE: 7.58
- R²: 0.34

These metrics indicate that the model explained approximately 34% of the variation in NVIDIA’s stock price during the test period, representing a considerable improvement over the ARIMA models.

#### Key Observation:
The forecast trend aligns with the general direction of NVIDIA’s stock price but fails to account for daily price volatility.

This is a known challenge in financial time series forecasting, as SARIMA models are more effective in data with clearer seasonal patterns, while stock prices are often driven by unpredictable market events.

### Conclusion from Visualization:
While the SARIMA(0, 2, 1)(1, 0, 1, 5) model provided the best numerical performance, the graph emphasizes the limitations of SARIMA models in capturing the high-frequency volatility typical of stock prices.

This reinforces the need to consider alternative models like GARCH, LSTM, or hybrid approaches for more precise stock market predictions in future studies.

# Overall Conclusion (NVDA)

While SARIMA models demonstrated reasonable performance in capturing the general trend, stock price forecasting requires more advanced models and external data sources to effectively handle volatility and market unpredictability.

This exercise highlighted the strengths and limitations of classical time series models, laying the foundation for future exploration into hybrid and machine learning-based forecasting techniques.

"""

















"""# Analysis of AMD Data"""



icker = "AMD"
df_amd = yf.download(ticker, start="2024-01-01", end="2025-01-01")

# Reset index to make 'Date' a column
df_amd.reset_index(inplace=True)

# Drop the 'ticker' level from multi-index columns if it exists
if isinstance(df_amd.columns, pd.MultiIndex):
    df_amd.columns = df_amd.columns.get_level_values(0)

# Rename columns to match the convention (Open_AMD, Close_AMD, etc.)
df_amd.rename(columns={
    'Open': 'Open_AMD',
    'High': 'High_AMD',
    'Low': 'Low_AMD',
    'Close': 'Close_AMD',
    'Adj Close': 'AdjClose_AMD',
    'Volume': 'Volume_AMD',
    'Date': 'Date_'
}, inplace=True)

print(df_amd.head())

"""### Univariate Analysis"""

# Plot Histograms and Boxplots for AMD Key Columns
features_amd = ['Open_AMD', 'High_AMD', 'Low_AMD', 'Close_AMD', 'Volume_AMD']

plt.figure(figsize=(12, 16))
for i, feature in enumerate(features_amd):
    plt.subplot(len(features_amd), 2, 2 * i + 1)
    sns.histplot(df_amd[feature], kde=True, color='skyblue')
    plt.title(f"{feature} - Histogram")

    plt.subplot(len(features_amd), 2, 2 * i + 2)
    sns.boxplot(x=df_amd[feature], color='lightcoral')
    plt.title(f"{feature} - Boxplot")

plt.tight_layout()
plt.show()

"""The histograms and boxplots of AMD’s stock data (Open, High, Low, Close, and Volume) for the year 2024 reveal the following insights:


**1. Open_AMD, High_AMD, Low_AMD, Close_AMD (Stock Prices)**

**Distribution Shape:**
- All price-related variables (Open, High, Low, Close) exhibit a slightly right-skewed distribution, indicating that on most trading days, AMD's stock price was concentrated between approximately
170, with some trading days reaching over $200.

**Boxplots (Outliers):**
- Visible outliers on the upper end of all price variables indicate specific days when AMD’s stock price spiked significantly.
- These outliers could correspond to key market events, such as earnings announcements, product releases, or general bullish market sentiment.

**2. Volume_AMD (Trading Volume)**

**Distribution Shape:**
- The trading volume histogram is highly right-skewed, suggesting that most trading days had moderate trading activity, while certain days experienced unusually high volumes.

**Boxplot (Outliers):**
- Several volume outliers are present, indicating days with exceptionally high trading activity.
- These spikes often reflect significant market events, including news releases or sudden investor reactions.

#### Key Takeaways:

- AMD’s stock prices fluctuated primarily within a range of
170, with occasional spikes above $200, identified as outliers.
- Trading volume showed higher variability, with frequent outliers reflecting days of heightened market activity.
- The presence of these outliers suggests that AMD’s stock was impacted by specific high-impact events in 2024, which could affect the accuracy of time series models if not accounted for.
"""



"""### Bivariate Analysis"""

# Select relevant columns
amd_corr_columns = ['Open_AMD', 'High_AMD', 'Low_AMD', 'Close_AMD', 'Volume_AMD']

# Compute correlation matrix
corr_amd = df_amd[amd_corr_columns].corr()

# Plot heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(corr_amd, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title("Correlation Matrix - AMD Stock Data")
plt.show()

"""1. Strong Positive Correlations Among Price Variables:
- Open_AMD, High_AMD, Low_AMD, and Close_AMD all exhibit very strong positive correlations (close to 1.00).
- This indicates that these price variables move closely together.

When the opening price is high, the high, low, and closing prices tend to be high as well, showing a consistent price pattern throughout the day.

2. Moderate Positive Correlation Between Volume and Prices:

- Volume_AMD has a moderate positive correlation with Open, High, Low, and Close prices (approximately 0.40 - 0.49).
- This suggests that higher trading volumes tend to coincide with higher prices, although the relationship is not as strong as the price-to-price correlations.
- This implies that while increased trading volume may reflect greater investor interest, it does not guarantee significant price movements in one direction.

### Multivariate Analysis


#### Hypothesis:

Higher trading volume is associated with higher opening prices, and this relationship is influenced by the closing price.

- Volume_AMD (x-axis) – Represents trading activity.
- Open_AMD (y-axis) – Reflects market sentiment at the start of the trading day.
- Close_AMD (color) – Indicates the final price, helping visualize if high volume days also end with high closing prices.
"""

plt.figure(figsize=(10, 6))
scatter = plt.scatter(
    df_amd['Volume_AMD'],
    df_amd['Open_AMD'],
    c=df_amd['Close_AMD'],
    cmap='coolwarm',
    alpha=0.7
)
plt.colorbar(scatter, label='Close_AMD')
plt.title('Multivariate Analysis: Volume vs. Open Price (Colored by Close Price) – AMD')
plt.xlabel('Volume_AMD')
plt.ylabel('Open_AMD')
plt.show()

"""The scatter plot partially supports the hypothesis that higher volume is associated with higher opening and closing prices, but the relationship is not strictly deterministic. While volume can reflect increased market interest, price movements still depend on additional factors.

## Model Building for AMD Data
"""

plt.figure(figsize=(12, 6))
plt.plot(df_amd['Date_'], df_amd['Close_AMD'], color='purple')
plt.title('AMD (AMD) Stock Price Time Series (2024)')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.grid(True)
plt.show()

"""The AMD (AMD) Stock Price Time Series (2024) graph displays the daily closing price throughout the year. The plot reveals significant volatility, with an upward trend in the early months, peaking around March, followed by a decline and fluctuating movements for the remainder of the year.


#### Key observations:

- Early surge in stock price, possibly reflecting positive earnings, product launches, or market optimism.
- Downward correction after March, with several fluctuations throughout mid and late 2024, indicating market uncertainties or sector-specific factors.
- End-of-year dip, suggesting possible year-end profit-taking, market corrections, or AMD-specific challenges.

This trend analysis serves as a foundation for identifying seasonal patterns, trends, and irregular events, which is crucial for selecting an appropriate time series model later on.
"""

# Convert Date to datetime if not already
df_amd['Date_'] = pd.to_datetime(df_amd['Date_'])
df_amd.set_index('Date_', inplace=True)

# Decomposition
result = seasonal_decompose(df_amd['Close_AMD'], model='additive', period=30)

# Plot Decomposed Components
result.plot()
plt.suptitle('AMD Stock Price – Time Series Decomposition (2024)', y=1.02)
plt.show()

"""This AMD Stock Price – Time Series Decomposition (2024) graph breaks down the closing price data into four components:


1. Original Series (Top Panel):

- Reflects the daily closing price movements throughout 2024.
- Shows high volatility with an increase early in the year, followed by declines and fluctuations later.

2. Trend Component:

- Identifies the underlying direction of the stock price over time.
- An upward trend is visible in the first quarter, followed by a downward correction in the second quarter, and stabilization towards the end of the year.

3. Seasonal Component:

- Reveals repeating patterns over shorter periods, likely weekly cycles in this case.
- Suggests consistent short-term patterns in price movements, possibly due to market behavior, trading activity, or news cycles.


4. Residual (Irregular) Component:

- Captures unexplained fluctuations that are not part of the trend or seasonal patterns.
- These residual spikes indicate irregular market events, such as earnings reports, geopolitical news, or product announcements.


#### Key Insight:

The clear seasonal component suggests that models accounting for seasonality, such as SARIMA, could perform better when forecasting AMD’s stock price.

## Modeling - ARIMA, PACF, ACF, ADF, Seasonality
### ADF Test
"""

# Extract Close price data for ADF Test
amd_close = df_amd['Close_AMD']

# Perform ADF Test
adf_result = adfuller(amd_close)

# Print Results
print(f"ADF Statistic: {adf_result[0]}")
print(f"p-value: {adf_result[1]}")
print("Critical Values:")
for key, value in adf_result[4].items():
    print(f"   {key}: {value}")

# Decision
if adf_result[1] < 0.05:
    print("The time series is stationary (p < 0.05).")
else:
    print("The time series is non-stationary (p >= 0.05). Differencing may be needed.")

"""This ADF test results indicate that the AMD stock price time series is non-stationary because the p-value is 0.4009, which is greater than 0.05.

This suggests that the time series has a trend or other non-stationary components, meaning that the mean and variance are not constant over time.

**What This Means:**

- Non-stationary data is problematic for time series modeling techniques like ARIMA because these models assume stationarity.

- Since the p-value is not below 0.05, we fail to reject the null hypothesis that the data has a unit root, meaning that the data is non-stationary.

- Differencing the data is necessary (taking the difference between consecutive observations) to transform it into a stationary series before applying ARIMA or other time series models.
"""

df_amd['Close_AMD_diff'] = df_amd['Close_AMD'].diff()
amd_close_diff = df_amd['Close_AMD_diff'].dropna()

adf_result_diff = adfuller(amd_close_diff)
print(f"ADF Statistic (Differenced): {adf_result_diff[0]}")
print(f"p-value (Differenced): {adf_result_diff[1]}")
print("Critical Values:")
for key, value in adf_result_diff[4].items():
    print(f"   {key}: {value}")

if adf_result_diff[1] < 0.05:
    print("The differenced series is stationary (p < 0.05).")
else:
    print("The differenced series is still non-stationary. Consider second-order differencing (d=2).")

"""ADF test on the differenced AMD stock price data confirms that the series is now stationary:

- ADF Statistic: -15.88
- p-value: 8.73e-29 (very small)
- Critical Values:
    - 1%: -3.4568
    - 5%: -2.8732
    - 10%: -2.5730

Since the p-value is significantly less than 0.05, we reject the null hypothesis that the data has a unit root, meaning the differenced series is stationary.

**What This Means:**

- Differencing was successful in making the AMD stock price data stationary.
- This is a crucial step before fitting ARIMA or SARIMA models, as they require stationarity for accurate predictions.
- The order of differencing (d) will be set to 1 in ARIMA and SARIMA models because one differencing step was enough to achieve stationarity.

## ACF and PACF
"""

# Plot ACF and PACF for the differenced data
fig, ax = plt.subplots(1, 2, figsize=(12, 5))

# ACF plot to determine q (MA order)
plot_acf(df_amd['Close_AMD'].diff().dropna(), ax=ax[0], lags=30)
ax[0].set_title("Autocorrelation Function (ACF) - AMD (Differenced)")

# PACF plot to determine p (AR order)
plot_pacf(df_amd['Close_AMD'].diff().dropna(), ax=ax[1], lags=30)
ax[1].set_title("Partial Autocorrelation Function (PACF) - AMD (Differenced)")

plt.tight_layout()
plt.show()

"""### Analysis of ACF and PACF Plots for AMD Differenced Series

Upon examining the ACF and PACF plots for the differenced AMD stock price data:

1. ACF Plot (Moving Average – q component):

- The ACF plot shows a gradual decay, with most lags within the blue confidence interval.
- This suggests that q (the MA order) is likely to be 0 because there is no significant spike indicating a short-term lag dependency.


2. PACF Plot (Autoregressive – p component):

- The PACF plot exhibits a sharp drop after lag 1, with the first lag being the most significant.
- This suggests that p (the AR order) is likely to be 1 because there is a clear cutoff after the first lag.


### Recommended Initial Model:
Based on these observations:

- p = 1 (from PACF’s sharp drop at lag 1)
- d = 1 (since differencing was necessary to achieve stationarity)
- q = 0 (from ACF’s gradual decay)

**Suggested ARIMA Model:
ARIMA(1, 1, 0)**

This would be the first model to start with for AMD stock price prediction.

Further refinements and other combinations can be tested based on performance metrics (e.g., RMSE, AIC).

### Splitting Data
"""

# Assuming df_amd is already loaded and processed
train_size = int(len(df_amd) * 0.7)
train = df_amd['Close_AMD'][:train_size]
test = df_amd['Close_AMD'][train_size:]

"""### ARIMA Models (Non-Seasonal)"""

# Model 1 - ARIMA(1, 1, 0)
arima_1 = ARIMA(
    train,
    order=(1, 1, 0),
    enforce_stationarity=False,
    enforce_invertibility=False
)
arima_1_fit = arima_1.fit()
forecast_1 = arima_1_fit.forecast(steps=len(test))

rmse_1 = np.sqrt(mean_squared_error(test, forecast_1))
r2_1 = r2_score(test, forecast_1)

print(f"ARIMA(1, 1, 0) - RMSE: {rmse_1:.2f}, R²: {r2_1:.2f}")
print(arima_1_fit.summary())

# Model 2 - ARIMA(2, 1, 2)
arima_2 = ARIMA(
    train,
    order=(2, 1, 2),
    enforce_stationarity=False,
    enforce_invertibility=False
)
arima_2_fit = arima_2.fit()
forecast_2 = arima_2_fit.forecast(steps=len(test))

rmse_2 = np.sqrt(mean_squared_error(test, forecast_2))
r2_2 = r2_score(test, forecast_2)

print(f"ARIMA(2, 1, 2) - RMSE: {rmse_2:.2f}, R²: {r2_2:.2f}")
print(arima_2_fit.summary())

"""### Overall Interpretation of ARIMA


Both ARIMA models performed poorly on AMD stock price data, as evidenced by negative R² values.

This suggests that the ARIMA models are not well-suited for this particular stock price data, which might have more complex patterns like seasonality or volatility clustering that ARIMA models are struggling to capture.

- RMSE values (15.27 and 15.25) indicate that the predictions deviate significantly from the actual closing prices.
- The Ljung-Box Test shows no strong autocorrelation in residuals, indicating some white noise behavior, which might explain why AR terms are not significant.

"""

plt.figure(figsize=(12, 6))
plt.plot(train.index, train, label='Train Data')
plt.plot(test.index, test, label='Test Data', color='orange')
plt.plot(test.index, forecast_1, label='ARIMA(1, 1, 0) Predictions', linestyle='dashed', color='red')
plt.title('ARIMA(1, 1, 0) Model Forecast – AMD Stock Price')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()
plt.show()

"""This visualization represents the ARIMA(1, 1, 0) model's forecast for AMD stock price in 2024. Here’s an analysis:


### Analysis of the Graph:
- Train Data (Blue): Historical stock prices used to train the ARIMA model.
- Test Data (Orange): Actual stock prices from the test set (unseen data during model training).
- ARIMA Predictions (Dashed Red Line): The model’s forecast for the future (test period).


#### Key Observations:

- The ARIMA(1, 1, 0) model is predicting a flat line during the test period.

- This is a common issue with simple ARIMA models (especially with low p and q values) when the differenced series appears stationary but lacks a clear pattern.
- The model essentially predicts the last observed value as the future value because the differencing step (d=1) makes the series stationary but removes the underlying trend.
- The forecast doesn't capture the actual fluctuations in the test data, reflecting poor predictive power, which is also confirmed by the negative R² (-0.10) and high RMSE (~15.27).

**What This Means:**

- The ARIMA(1, 1, 0) model is too simple to capture the volatility and trends in AMD's stock price.

- Stock price data is often more complex and may have seasonality or short-term patterns, which this basic ARIMA model fails to capture.

- SARIMA models with seasonal components and higher-order AR and MA terms tend to perform better for stock price data.
SARIMA Models (Seasonal ARIMA)

## SARIMA Models (Seasonal ARIMA)
"""

# Model 3 - SARIMA(1, 2, 2)(0, 1, 1, 5)
sarima_1 = SARIMAX(
    train,
    order=(1, 2, 2),
    seasonal_order=(0, 1, 1, 5),
    enforce_stationarity=False,
    enforce_invertibility=False
)
sarima_1_fit = sarima_1.fit()
forecast_1 = sarima_1_fit.forecast(steps=len(test))

rmse_1 = np.sqrt(mean_squared_error(test, forecast_1))
r2_1 = r2_score(test, forecast_1)

print(f"SARIMA(1, 2, 2)(0, 1, 1, 5) - RMSE: {rmse_1:.2f}, R²: {r2_1:.2f}")
print(sarima_1_fit.summary())

# Model 4 - SARIMA(1, 2, 2)(1, 1, 1, 5)
sarima_2 = SARIMAX(
    train,
    order=(1, 2, 2),
    seasonal_order=(1, 1, 1, 5),
    enforce_stationarity=False,
    enforce_invertibility=False
)
sarima_2_fit = sarima_2.fit()
forecast_2 = sarima_2_fit.forecast(steps=len(test))

rmse_2 = np.sqrt(mean_squared_error(test, forecast_2))
r2_2 = r2_score(test, forecast_2)

print(f"SARIMA(1, 2, 2)(1, 1, 1, 5) - RMSE: {rmse_2:.2f}, R²: {r2_2:.2f}")
print(sarima_2_fit.summary())

"""### Key Observations – SARIMA Models for AMD Stock Price

### Model 1 – SARIMA(1, 2, 2)(0, 1, 1, 5):
- RMSE: 10.48 – Indicates a moderate error in the model's predictions compared to actual test data.
- R²: 0.48 – Suggests that the model explains approximately 48% of the variation in the AMD stock price during the test period.
- Seasonality Component (5 trading days) – This implies that the model assumes potential weekly patterns in stock prices.
- Significant Seasonal Moving Average Term (ma.S.L5) – The coefficient is -0.9092 (p < 0.05), indicating a strong negative seasonal relationship with past values at a lag of 5 days (weekly).

### Model 2 – SARIMA(1, 2, 2)(1, 1, 1, 5):
- RMSE: 10.49 – Similar error level to Model 1.
- R²: 0.48 – The explanatory power is identical to Model 1.
- Seasonality Component (5 trading days):
    - Seasonal AR(1) (ar.S.L5) is not significant (p > 0.05), suggesting that the seasonal autoregressive component may not improve the model.
    - Seasonal MA(1) (ma.S.L5) is significant with a coefficient of -0.9093 (p < 0.05), reinforcing the same strong negative weekly pattern seen in Model 1.

#### Key Takeaways:
- Both models yield nearly identical performance in terms of RMSE and R².
- The weekly seasonal component (MA.S.L5) is the most important feature in both models, suggesting weekly patterns in AMD stock price movements.
- The non-seasonal AR and MA terms are not statistically significant, indicating that short-term autoregressive and moving average effects might not be crucial for this dataset.
- Inclusion of the additional seasonal AR(1) term in Model 2 does not provide a notable improvement over Model 1.
"""

# Fit the SARIMA model with your best parameters
sarima_model = SARIMAX(
    train,
    order=(1, 2, 2),
    seasonal_order=(0, 1, 1, 5),
    enforce_stationarity=False,
    enforce_invertibility=False
)
sarima_fit = sarima_model.fit()

# Forecast for the length of the test set
forecast_sarima = sarima_fit.forecast(steps=len(test))

# Plotting the results
plt.figure(figsize=(10, 6))
plt.plot(train.index, train, label='Train Data', color='blue')
plt.plot(test.index, test, label='Test Data', color='green')
plt.plot(test.index, forecast_sarima, label='SARIMA(1,2,2)(0,1,1,5) Forecast', color='red', linestyle='--')
plt.title('SARIMA(1,2,2)(0,1,1,5) Forecast vs Actual')
plt.xlabel('Date')
plt.ylabel('Stock Price')
plt.legend()
plt.show()

"""While the SARIMA(1, 2, 2)(0, 1, 1, 5) model captures the general trend, its inability to account for stock price volatility highlights the limitations of SARIMA models for short-term stock price forecasting. For improved performance, more advanced models like GARCH (to handle volatility) or machine learning models (e.g., XGBoost, LSTM) could be considered.



#### Final Evaluation:

- SARIMA models incorporating seasonality outperformed non-seasonal ARIMA models, demonstrating that weekly trading patterns (5-day cycles) play a role in AMD’s stock price behavior.

- However, all models exhibited limitations in predicting sharp market fluctuations, highlighting the challenges of using traditional linear models for stock price forecasting.

- While SARIMA models provided a reasonable trend estimate, they lacked the flexibility to react to sudden market movements, which is critical in stock price forecasting.
"""



"""## Data Collection and Preprocessing (RIVN)"""

# Download RIVN stock data from January 1, 2024, to January 1, 2025
ticker = "RIVN"
df_rivn = yf.download(ticker, start="2024-01-01", end="2025-01-01")

# Reset index to make 'Date' a column
df_rivn.reset_index(inplace=True)

# If multi-index columns are present, drop them
if isinstance(df_rivn.columns, pd.MultiIndex):
    df_rivn.columns = df_rivn.columns.get_level_values(0)

# Rename columns to match the convention (Open_RIVN, Close_RIVN, etc.)
df_rivn.rename(columns={
    'Open': 'Open_RIVN',
    'High': 'High_RIVN',
    'Low': 'Low_RIVN',
    'Close': 'Close_RIVN',
    'Adj Close': 'AdjClose_RIVN',
    'Volume': 'Volume_RIVN',
    'Date': 'Date_'
}, inplace=True)

# Display the first few rows
print(df_rivn.head())

"""### Univariate Analysis"""

# Plot Histograms and Boxplots for RIVN Key Columns
features_rivn = ['Open_RIVN', 'High_RIVN', 'Low_RIVN', 'Close_RIVN', 'Volume_RIVN']

plt.figure(figsize=(12, 16))
for i, feature in enumerate(features_rivn):
    plt.subplot(len(features_rivn), 2, 2 * i + 1)
    sns.histplot(df_rivn[feature], kde=True, color='skyblue')
    plt.title(f"{feature} - Histogram")

    plt.subplot(len(features_rivn), 2, 2 * i + 2)
    sns.boxplot(x=df_rivn[feature], color='lightcoral')
    plt.title(f"{feature} - Boxplot")

plt.tight_layout()
plt.show()

"""The histograms and boxplots for RIVN stock data (Open, High, Low, Close, and Volume) reveal several key insights:

1. Open, High, Low, Close Prices:

  - The distributions of the Open, High, Low, and Close prices are right-skewed, with most values concentrated between
15, but a few outliers above $20.

  - The boxplots confirm the presence of outliers, especially on the higher end of the price range, indicating that RIVN experienced a few days with exceptionally high prices compared to its typical range.
  - The quartile range is relatively tight, suggesting RIVN’s price has been mostly stable within this range, aside from occasional price spikes.

2. Volume:

  - The Volume histogram is highly right-skewed, with most trading volumes clustering at the lower end (below 50 million shares) but a few extreme outliers above 200 million shares.
  - The boxplot highlights these extreme trading volume outliers, indicating that on certain days, trading activity surged significantly, possibly due to earnings announcements, news, or market events.

#### Key Observations Summary:
- **Price Stability:** The majority of RIVN’s stock prices remained within a tight range between
15, but outliers beyond $20 indicate volatility on certain days.
- **Trading Volume Volatility:** Volume outliers suggest significant fluctuations in market interest, which may correspond to key company announcements, news releases, or general market sentiment changes.
- **Outliers:** Notable outliers in both price and volume data indicate potential days of abnormal market behavior, which might require further investigation.
"""



"""### Bivariate Analysis"""

# Correlation Matrix for RIVN Data
plt.figure(figsize=(8, 6))
corr_matrix = df_rivn[['Open_RIVN', 'High_RIVN', 'Low_RIVN', 'Close_RIVN', 'Volume_RIVN']].corr()

sns.heatmap(corr_matrix, annot=True, cmap="RdBu_r", fmt=".2f", linewidths=0.5)
plt.title("Correlation Matrix - RIVN Stock Data")
plt.show()



"""The correlation matrix for RIVN stock data reveals several important insights:

1. Strong Positive Correlations Among Price Variables:

  - Open_RIVN, High_RIVN, Low_RIVN, and Close_RIVN are all highly positively correlated (0.98 to 0.99).
  - This is expected because stock prices tend to move together throughout the trading day. If a stock opens high, it is likely to reach a higher high, low, and close price.

2. Weak/Negative Correlation with Volume:

  - Volume_RIVN shows weak and slightly negative correlations with Open_RIVN (-0.02), Low_RIVN (-0.07), and Close_RIVN (-0.04). It has a near-zero correlation with High_RIVN (0.01).
  - This suggests that trading volume is not strongly associated with daily price levels. Higher trading volume does not necessarily correspond to higher or lower prices.

#### Key Takeaways:

- Price variables (Open, High, Low, Close) are interconnected, moving in the same direction.
- Volume seems to be influenced by other factors, like market sentiment, news, or external events, rather than daily price levels.
- Low correlation between Volume and Price can imply that price changes are not heavily driven by trading volume for RIVN in this period.


## Multivariate Analysis

**Hypothesis:**

Higher trading volume is associated with more extreme stock price movements (either higher or lower), especially impacting the opening price. We expect to see higher volume during periods of price spikes or dips, and this relationship may become more visible when we color the scatter plot by the closing price.
"""

plt.figure(figsize=(10, 6))
scatter = plt.scatter(
    df_rivn['Volume_RIVN'],
    df_rivn['Open_RIVN'],
    c=df_rivn['Close_RIVN'],
    cmap='coolwarm',
    alpha=0.7,
    edgecolor='k'
)
plt.colorbar(scatter, label='Close Price (RIVN)')
plt.title('Multivariate Analysis: Volume vs. Open Price (Colored by Close Price) – RIVN')
plt.xlabel('Volume')
plt.ylabel('Open Price')
plt.show()

"""#### Key Insights:

**Low Volume Clusters:**
- The majority of the data points are concentrated in the lower volume range (below 50 million). These points show a wide range of open prices, indicating that low trading volume is common regardless of stock price levels.

**High Price and High Volume Spikes:**
- There are few instances with both high volume and higher stock prices (red-colored points). This suggests that significant trading activity is often linked to higher stock price levels, likely reflecting news events, earnings releases, or other catalysts.

**Low Price and Low Volume Cluster:**
- The blue-colored points representing lower closing prices tend to be clustered at lower volume levels, indicating that days with low trading activity often correspond to lower stock price performance.

**Volume Outliers:**
- A few high-volume outliers exceed 200 million shares traded. These points are associated with both mid-range and lower stock prices, suggesting potential sell-offs or unusual trading days.



### Interpretation Regarding the Hypothesis:
The hypothesis was partially supported.

- Higher volume days do align with price fluctuations, particularly when there are upward price surges.
- However, volume alone is not a consistent predictor of price direction.
- Some high-volume days still corresponded with lower or mid-range prices, possibly indicating selling pressure.




## Model Building (RIVN)
"""

plt.figure(figsize=(12, 6))
plt.plot(df_rivn['Date_'], df_rivn['Close_RIVN'], color='purple')
plt.title('RIVN (Rivian) Stock Price Time Series (2024)')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

"""In 2024, Rivian Automotive Inc. (RIVN) experienced significant stock price fluctuations influenced by various internal developments and external market factors.


**Key Events and Their Impact on Rivian's Stock Price:**

1. **Production Challenges and Supply Chain Issues:**

- Early to Mid-2024: Rivian faced supply chain disruptions, particularly component shortages, which hindered production capabilities. These challenges led to missed production targets, negatively impacting investor confidence and contributing to a 43% decline in the stock price over the year.

2. **Expansion of Customer Base Beyond Amazon:**

- Late 2024: Rivian announced plans to sell its all-electric delivery vans to companies other than Amazon, its initial exclusive customer. This strategic move aimed to diversify revenue streams and reduce dependency on a single client, leading to a positive reception in the market.

3. **Strategic Partnerships and Investments:**

- November 2024: The U.S. Department of Energy extended a 6.6 billion loan to Rivian, facilitating the resumption of construction for a 5 billion manufacturing plant in Georgia. This financial support was viewed as a significant boost to Rivian's production expansion plans, resulting in a 22% surge in stock price following the announcement.

- December 2024: Rivian and Volkswagen expanded their joint venture to $5.8 billion, focusing on advancing electric vehicle technology. This collaboration was interpreted as a strong endorsement of Rivian's technological capabilities, leading to a 20% increase in the company's stock price.

4. **Analyst Coverage and Market Outlook:**

- December 2024: Benchmark analysts initiated coverage of Rivian with a positive outlook, predicting the company would capture a significant portion of the EV market over the next decade. This optimistic forecast contributed to a 13% rise in Rivian's stock price.
"""

from statsmodels.tsa.seasonal import seasonal_decompose

# Assuming your data is daily, set the frequency accordingly (e.g., 5-day week)
df_rivn['Date_'] = pd.to_datetime(df_rivn['Date_'])
df_rivn.set_index('Date_', inplace=True)

# Decompose the time series
decomposition = seasonal_decompose(df_rivn['Close_RIVN'], model='additive', period=5)

# Plot Decomposition
plt.figure(figsize=(10, 8))
decomposition.plot()
plt.suptitle('RIVN Stock Price – Time Series Decomposition (2024)', fontsize=14)
plt.tight_layout()
plt.show()

"""The time series decomposition plot of Rivian’s stock price in 2024 is broken down into four key components:

1. Observed (Close_RIVN):

- The observed plot shows the overall stock price movements. Rivian's stock price began high early in the year, declined sharply in the first quarter, fluctuated throughout the year, and demonstrated some recovery towards the end of the year.

2. Trend:

- The trend component highlights the broader price movement over time. There is a clear downward trend in the early months, followed by a moderate upward recovery in the second half of the year, aligning with Rivian’s production and sales adjustments and potential investor optimism.

3. Seasonal:

- A noticeable seasonality pattern is present with small, repetitive fluctuations. This could reflect weekly trading patterns or recurring investor behaviors, such as increased activity around earnings releases or other scheduled announcements.

4. Residual:

- The residual plot captures the random noise in the stock price data. Most residuals appear centered around zero, indicating that the model captures the primary trend and seasonal effects reasonably well. However, there are a few spikes, suggesting that some unexpected events or news may have caused price volatility.


#### Key Insights:
- The stock price was significantly affected by negative sentiment early in the year, likely due to production struggles and market concerns.
- A modest upward trend later in the year may reflect investor optimism following Rivian’s strategy adjustments, such as expanding its customer base beyond Amazon.
- The seasonality suggests regular, minor price fluctuations, potentially driven by typical trading cycles or investor reactions to company news.


## Modeling - ARIMA, PACF, ACF, ADF, Seasonality
### ADF Test
"""

# Extract Close price data for ADF Test
rivn_close = df_rivn['Close_RIVN']

# Perform ADF Test
adf_result = adfuller(rivn_close)

# Print Results
print(f"ADF Statistic: {adf_result[0]}")
print(f"p-value: {adf_result[1]}")
print("Critical Values:")
for key, value in adf_result[4].items():
    print(f"   {key}: {value}")

# Decision
if adf_result[1] < 0.05:
    print("The time series is stationary (p < 0.05).")
else:
    print("The time series is non-stationary (p >= 0.05). Differencing may be needed.")



"""- ADF Statistic: -3.24 – This value is lower than the 5% critical value (-2.87), which suggests that we can reject the null hypothesis.
- p-value: 0.0177 – Since p < 0.05, we reject the null hypothesis that the series is non-stationary.

- Conclusion: The RIVN stock price time series is stationary.

**Key Takeaway:**
- Since the RIVN stock price series is already stationary, there is no need for differencing before applying ARIMA or SARIMA models.
- This is a positive outcome, as stationary data is typically easier to model and forecast accurately.

### ACF and PACF
"""

# Plot ACF and PACF
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plot_acf(df_rivn['Close_RIVN'], lags=30, ax=plt.gca())
plt.title('Autocorrelation Function (ACF) - RIVN')

plt.subplot(1, 2, 2)
plot_pacf(df_rivn['Close_RIVN'], lags=30, ax=plt.gca())
plt.title('Partial Autocorrelation Function (PACF) - RIVN')

plt.tight_layout()
plt.show()

"""1. ACF (Autocorrelation Function):

- The ACF plot shows a gradual decay, suggesting the presence of strong positive autocorrelations over time.
- This pattern is often indicative of a non-stationary series, though your ADF test suggested stationarity. This could imply some residual trend or long-term dependencies.
- Significant lags indicate that past values influence future values over an extended period.


2. PACF (Partial Autocorrelation Function):

- The PACF plot has a significant spike at lag 1 and then quickly tapers off, suggesting that an AR(1) or AR(2) model might be appropriate.
- The sharp drop after lag 1 is a classic indicator of an autoregressive process of low order.


### Implications for Model Selection:

- The ACF and PACF patterns suggest that a low-order ARIMA model (such as ARIMA(1, 1, 0) or ARIMA(2, 1, 0)) might be a reasonable starting point.
- The gradual decline in ACF and the quick drop in PACF align with the need for differencing (d=1), which is consistent with the ADF test showing stationarity after differencing.



### Split Data
"""

# Split the data into train and test sets
train_size = int(len(df_rivn) * 0.7)
train, test = df_rivn['Close_RIVN'][:train_size], df_rivn['Close_RIVN'][train_size:]

"""## ARIMA Models"""

# ARIMA(1, 1, 0)
arima_1 = ARIMA(train, order=(1, 1, 0))
arima_1_fit = arima_1.fit()
forecast_1 = arima_1_fit.forecast(steps=len(test))

rmse_1 = np.sqrt(mean_squared_error(test, forecast_1))
r2_1 = r2_score(test, forecast_1)

print(f"ARIMA(1, 1, 0) - RMSE: {rmse_1:.2f}, R²: {r2_1:.2f}")
print(arima_1_fit.summary())

# ARIMA(2, 1, 0)
arima_2 = ARIMA(train, order=(2, 1, 0))
arima_2_fit = arima_2.fit()
forecast_2 = arima_2_fit.forecast(steps=len(test))

rmse_2 = np.sqrt(mean_squared_error(test, forecast_2))
r2_2 = r2_score(test, forecast_2)

print(f"ARIMA(2, 1, 0) - RMSE: {rmse_2:.2f}, R²: {r2_2:.2f}")
print(arima_2_fit.summary())

"""1. ARIMA(1, 1, 0)  - RMSE: 2.56, R²: -1.86
- Root Mean Squared Error (RMSE): 2.56 is relatively high, indicating that the model struggles to capture the stock price movements accurately.
- R² (R-squared): -1.86 is a very poor result. A negative R² means the model performs worse than simply predicting the mean of the data.

This suggests that the ARIMA(1, 1, 0) model is not capturing the underlying patterns or trends in RIVN’s stock price.


2. ARIMA(2, 1, 0) - RMSE: 2.52, R²: -1.77
- RMSE: 2.52 is slightly better than the first model but still relatively high.
- R²: -1.77, although marginally better, is still negative, indicating that this model also fails to explain the variability in the stock price.

It again suggests the model is underperforming compared to a naive average prediction.


#### Key Observations:
- Both models are inadequate for predicting RIVN's stock price. The negative R² values suggest that the models are not suitable for this dataset.
- High RMSE values suggest the forecasts deviate significantly from the actual stock prices.
- Simple ARIMA models might not be sufficient for RIVN stock data due to its complexity, volatility, and potential seasonality.


#### Possible Reasons for Poor Performance:

1. **Stock Price Volatility:** RIVN’s stock is likely highly volatile due to factors such as earnings reports, EV industry developments, and macroeconomic conditions, which ARIMA models struggle to capture.
2. **Non-stationarity:** Differencing was applied, but the remaining patterns may still not be well-suited to ARIMA without more complexity.
3. **Lack of Seasonality Handling:** These ARIMA models do not account for seasonality (SARIMA would address this).
4. **Short-term Dependence:** ARIMA(1,1,0) and ARIMA(2,1,0) only consider short-term lags. Complex stock price movements often require more sophisticated models.




## SARIMA Models
"""

# Assuming the dataframe is df_rivn and 'Close_RIVN' is the target column
train_size = int(len(df_rivn) * 0.7)
train, test = df_rivn['Close_RIVN'][:train_size], df_rivn['Close_RIVN'][train_size:]

# Model 1 - SARIMA(2, 0, 1)(0, 1, 1, 5)
sarima_1 = SARIMAX(
    train,
    order=(2, 0, 1),
    seasonal_order=(0, 1, 1, 5),
    enforce_stationarity=False,
    enforce_invertibility=False
)
sarima_1_fit = sarima_1.fit()
forecast_1 = sarima_1_fit.forecast(steps=len(test))

rmse_1 = np.sqrt(mean_squared_error(test, forecast_1))
r2_1 = r2_score(test, forecast_1)

print(f"SARIMA(2, 0, 1)(0, 1, 1, 5) - RMSE: {rmse_1:.2f}, R²: {r2_1:.2f}")
print(sarima_1_fit.summary())

# Model 2 - SARIMA(1, 0, 1)(0, 1, 1, 5)
sarima_2 = SARIMAX(
    train,
    order=(1, 0, 1),
    seasonal_order=(0, 1, 1, 5),
    enforce_stationarity=False,
    enforce_invertibility=False
)
sarima_2_fit = sarima_2.fit()
forecast_2 = sarima_2_fit.forecast(steps=len(test))

rmse_2 = np.sqrt(mean_squared_error(test, forecast_2))
r2_2 = r2_score(test, forecast_2)

print(f"SARIMA(1, 0, 1)(0, 1, 1, 5) - RMSE: {rmse_2:.2f}, R²: {r2_2:.2f}")
print(sarima_2_fit.summary())

"""1. SARIMA(2, 0, 1)(0, 1, 1, 5) - RMSE: 1.91, R²: -0.59
- Root Mean Squared Error (RMSE): 1.91 is a lower value compared to the ARIMA models, indicating that the SARIMA model provides a more accurate prediction of RIVN’s stock price.
- R² (R-squared): -0.59 is still a negative value, indicating that this model underperforms compared to a simple mean prediction.

However, it is notably better than the ARIMA models, suggesting some improvement from incorporating seasonality.

2. SARIMA(1, 0, 1)(0, 1, 1, 5) - RMSE: 1.92, R²: -0.60
- RMSE: 1.92, nearly identical to the first SARIMA model, indicating similar predictive accuracy.
- R²: -0.60, also a negative value, indicating poor performance but slightly worse than the SARIMA(2, 0, 1) model.

#### Key Observations:
- Both SARIMA models outperform the ARIMA models in terms of RMSE, suggesting that the introduction of seasonal differencing and weekly seasonality is capturing some structure in the data.
- R² values remain negative, implying that the models still struggle to explain the variance in the stock price, which may be due to:
    - The high volatility and irregular fluctuations in RIVN’s stock price.
    - The presence of external influences (e.g., market news, earnings reports) that a univariate SARIMA model cannot account for.
- SARIMA(2, 0, 1)(0, 1, 1, 5) is the better performing model, with a slightly lower RMSE and a better R² value.
"""

# Plot the best SARIMA model (assuming SARIMA(2, 0, 1)(0, 1, 1, 5) is the best based on RMSE and AIC)
plt.figure(figsize=(12, 6))
plt.plot(train.index, train, label='Train Data')
plt.plot(test.index, test, label='Test Data', color='orange')
plt.plot(test.index, forecast_1, label='SARIMA(2, 0, 1)(0, 1, 1, 5) Predictions', linestyle='dashed', color='red')
plt.title('Best SARIMA Model Forecast – RIVN Stock Price')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()
plt.show()

"""### Conclusion from the Plot:

- While the SARIMA(2, 0, 1)(0, 1, 1, 5) model is the best SARIMA model tested, it still struggles to predict RIVN’s volatile and rapidly changing stock prices.

- RIVN's stock price behavior is likely influenced by external market news, earnings announcements, or investor sentiment, which are not captured by a purely time-series-based model like SARIMA.

- Combining SARIMA with external variables (SARIMAX) or exploring machine learning models (e.g., XGBoost, LSTM) may improve prediction accuracy.

# Data Exploration between the stocks

## Step 1: Combining the 3 DataFrames - NVDA, AMD, RIVN
"""

# Define the ticker symbols
tickers = ['NVDA', 'AMD', 'RIVN']

# Download historical data for the specified tickers
data = yf.download(tickers, start='2024-01-01', end='2024-12-31')

# Extract the 'Close' prices and reshape the DataFrame
close_prices = data['Close']
close_prices.columns = ['NVDA_Close', 'AMD_Close', 'RIVN_Close']

# Forward-fill missing values
close_prices.ffill(inplace=True)

# Save the merged DataFrame to a CSV file
close_prices.to_csv('merged_stock_data.csv')

# Display the first few rows of the DataFrame
print(close_prices.head())



"""## Step 2: Visualize the Closing Prices for all 3 Stocks"""

# Calculate daily returns
daily_returns = close_prices.pct_change().dropna()

# Display the first few rows
print(daily_returns.head())

# --- Step 2: Visualize the Closing Prices for all 3 Stocks ---
plt.figure(figsize=(12, 6))
plt.plot(close_prices['NVDA_Close'], label='NVIDIA (NVDA)')
plt.plot(close_prices['AMD_Close'], label='AMD')
plt.plot(close_prices['RIVN_Close'], label='RIVN')
plt.title('Stock Price Comparison: NVIDIA, AMD, RIVN (2024)')
plt.xlabel('Date')
plt.ylabel('Closing Price')
plt.legend()
plt.grid(True)
plt.show()



"""Since NVIDIA (NVDA) and AMD are both in the semiconductor industry, and their stock prices often respond similarly to industry-wide factors like:

- Chip shortages
- AI advancements
- Earnings reports from competitors like Intel
- Global demand for GPUs and CPUs

## Analysis for Stock Price Comparison (NVIDIA, AMD, RIVN):

### NVIDIA (NVDA) and AMD:
The chart reveals a strong visual correlation between NVIDIA and AMD. Their stock prices follow similar upward and downward trends throughout the year, suggesting that both are influenced by common market drivers like:

- Growth in artificial intelligence (AI).
- Demand for GPUs and chips in gaming, data centers, and machine learning.
- Industry-wide supply chain issues and technological developments.

### Rivian (RIVN):
Rivian, an electric vehicle (EV) company, shows a much lower price range and moves independently of NVIDIA and AMD.

- This indicates that Rivian is driven by different market factors, such as EV adoption rates, production capacity, competition from Tesla, and consumer demand for electric vehicles.
- The low price range compared to the tech giants emphasizes the volatility and uncertainty in the EV startup space.


#### Key Takeaway:

- If you were treating these 3 stocks as a portfolio, NVIDIA and AMD are highly correlated and may not offer strong diversification.

- Rivian, on the other hand, could serve as a diversification asset since it behaves differently due to its focus on the EV industry.

## Step 3: Correlation Matrix
"""

correlation_matrix = close_prices.corr()
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix - NVIDIA, AMD, RIVN (2024)')
plt.show()

"""### Key Observations:

1. NVIDIA & AMD: Correlation = -0.40 (Negative Correlation)

    - Surprisingly, this indicates a moderate negative correlation, which is unusual given that both are semiconductor companies.
    - This could be due to specific company news, earnings differences, or one outperforming the other (e.g., NVIDIA's dominance in AI and GPUs).

2. NVIDIA & Rivian: Correlation = -0.13 (Weak Negative Correlation)
    - Minimal correlation, indicating that NVIDIA’s performance is largely independent of Rivian’s.
    - This makes Rivian a potential diversification asset when combined with NVIDIA in a portfolio.

3. AMD & Rivian: Correlation = -0.30 (Weak Negative Correlation)
    - Slightly stronger negative correlation compared to NVIDIA-Rivian, but still suggests low dependency.
    - AMD and Rivian stocks are driven by different market factors, making them largely independent.


#### Final Takeaway:
- Rivian serves as a good diversifier, as it moves independently from both NVIDIA and AMD.
- The negative correlation between NVIDIA and AMD is unusual and could signal market competition effects, AI race dynamics, or NVIDIA outperforming AMD in key areas like GPUs for AI.

## Step 4: Trends and Patterns Analysis (14-Day Moving Average)
"""

close_prices_rolling = close_prices.rolling(window=14).mean()

plt.figure(figsize=(12, 6))
plt.plot(close_prices_rolling['NVDA_Close'], label='NVIDIA (NVDA) - 14-Day MA')
plt.plot(close_prices_rolling['AMD_Close'], label='AMD - 14-Day MA')
plt.plot(close_prices_rolling['RIVN_Close'], label='RIVN - 14-Day MA')
plt.title('14-Day Moving Average Stock Prices - NVIDIA, AMD, RIVN (2024)')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.grid(True)
plt.show()

"""### Key Observations:

1. NVIDIA (NVDA):

- Strong uptrend from January to March, reaching a peak above $200, likely driven by AI growth and strong earnings.
- Decline from April to May, followed by stabilization and slight recovery mid-year.
- Downward trend towards year-end, possibly reflecting broader tech market corrections or profit-taking.

2. AMD:

- Gradual rise in the first half of the year, peaking in mid-summer (around $130), aligning with NVIDIA's strength.
- Similar decline post-summer, but less pronounced compared to NVIDIA.
- Smoother and more gradual movements compared to NVIDIA, showing less volatility but correlated patterns.

3. Rivian (RIVN):

- Relatively flat and lower-priced stock throughout the year.
- Slight dip from January to May, followed by minor upward momentum in the second half.
- Noticeable volatility in the latter part of the year, possibly tied to EV market sentiment, production updates, or earnings reports.


#### Key Insights:
- NVIDIA and AMD show a clear pattern of industry correlation, reflecting similar trends, though NVIDIA exhibited higher volatility and sharper swings.
- Rivian (RIVN) remained detached from the semiconductor-driven patterns, reflecting EV sector-specific performance.
- Volatility patterns differ, with Rivian being more stable overall but experiencing isolated price jumps, while NVIDIA had sharper peaks and valleys.


## Step 5: Daily Returns for Volatility / Irregular Patterns
"""

# Calculate daily returns
returns_df = close_prices.pct_change()

# Plot daily returns
plt.figure(figsize=(12, 6))
plt.plot(returns_df['NVDA_Close'], label='NVIDIA (NVDA)', alpha=0.7)
plt.plot(returns_df['AMD_Close'], label='AMD', alpha=0.7)
plt.plot(returns_df['RIVN_Close'], label='RIVN', alpha=0.7)
plt.title('Daily Returns - NVIDIA, AMD, RIVN (2024)')
plt.xlabel('Date')
plt.ylabel('Daily Return')
plt.axhline(y=0, color='black', linestyle='--', linewidth=0.8)
plt.legend()
plt.grid(True)
plt.show()

"""## Key Observations:

1. NVIDIA (NVDA) and AMD:

- Moderate and similar fluctuations in daily returns, reinforcing their correlation.
- Smoother and more stable movements compared to Rivian, indicating lower day-to-day volatility.
- Occasional spikes, likely in response to earnings reports, product launches, or industry news.

2. Rivian (RIVN):

- Notably higher volatility with frequent sharp spikes and dips, reflecting higher risk and price sensitivity.
- Sudden large positive and negative returns, indicating greater uncertainty and market reactions to company-specific or EV sector developments.
- More irregular return pattern compared to the smoother NVDA and AMD movements.

---

# Key Insights and Final Conclusion:

- Rivian is the most volatile stock, meaning higher potential returns but also greater risk.

- NVIDIA and AMD are relatively stable but still display some synchronized volatility, suggesting sector-driven reactions to external events (e.g., AI advancements, chip shortages, or tech sector movements).

- Volatility analysis emphasizes the need to balance risk when combining stocks into a portfolio, especially mixing stable tech stocks (NVDA/AMD) with high-risk EV stocks like Rivian.
"""

